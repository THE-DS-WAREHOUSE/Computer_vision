from scipy.spatial.distance import euclidean # to calculate euclidean distance between objects
from imutils import perspective #used sort the points based on their x-coordinates 
from imutils import contours # to extract contours arrays and manipulate them
import numpy as np # to do calculations
import imutils # to access imutils functions
import cv2 #to perform computer vision algorithms and manipulate camera modules
import time # this only because I was using a GoPro as a Webcam and GoPro's software has a banner that shos in first seconds of turning on Webcam 
# I need to impkement a time.sleep() to not crash the the program due to that banner (you can ignore it if you have a normal Webcam)

cap = cv2.VideoCapture(2) # access the webcam module (Check yours first, every camera have different camera module, if you have a laptop integrated camera is 0)
time.sleep(5) # timer to not crash the program
while cap.isOpened(): # while camera is active
    ret, frame = cap.read() # we extract what the camera is capturing as a frame
    if frame is None: # check if the frame is not empty (sometimes you need to restart kernell due to this issue)
        print("Failed") 
    else: # if we capture a frame with objects the
        gray_image = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # change the image to gray scale 
        blured_image = cv2.GaussianBlur(gray_image, (15, 15), 0) #blur the image using Gaussian blur (the bigger the number the blured the image, use odd numbers)
        edged = cv2.Canny(blured_image, 50, 100) # use Canny algorithm to detect edges (countours of objects)
        edged = cv2.dilate(edged, None, iterations=1) # dilate contours camptured (makes them bigger)
        edged = cv2.erode(edged, None, iterations=1) # contours get eroded (makes them thinner)
        cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # we find the contours and extract them
        if len(cnts[0]) > 0: # we need to check if we have at least one contour array
            cnts = imutils.grab_contours(cnts) # we take the contours
            (cnts, _) = contours.sort_contours(cnts) # we order them using x-coordinates
            cnts = [x for x in cnts if cv2.contourArea(x) > 100] # we keep big enough contours,  you can modify this value filter
            cv2.drawContours(frame, cnts, -1, (0,255,0), 3) # draw contours 
            if len(cnts) > 0: # if we have at least one contour then
                ref_object = cnts[0] # we select the object to the left as aour reference of size (size most be known, idealy this is a square)
                box = cv2.minAreaRect(ref_object) # extract the minmium rectangle that covers the object (in this case is a square because a coin is size simetrical)
                box = cv2.boxPoints(box) # extract it points
                box = np.array(box, dtype="int") # cast them as an array
                box = perspective.order_points(box) # order those points
                (tl, tr, br, bl) = box # extract sides of the box generated by the object (top-left, top-right, bottom-right, bottom-left in that order)
                dist_in_pixel = euclidean(tl, tr) # as long as it generates a square we can choose any top or bottom to calculate its distances in pixels
                dist_in_cm = 1.5 # known size of the rectangle (in my case was a diameter of a coin in cm)
                pixel_per_cm = dist_in_pixel/dist_in_cm # now we convert pixels to cm
                for cnt in cnts: # for every contour
                    box = cv2.minAreaRect(cnt) # we enclose the contour 
                    box = cv2.boxPoints(box) # generate a box (it could be a rectangle)
                    box = np.array(box, dtype="int") # extract coordinates as an array
                    box = perspective.order_points(box) # order points
                    (tl, tr, br, bl) = box # extract sides of the box generated by the object (top-left, top-right, bottom-right, bottom-left in that order)
                    cv2.drawContours(frame, [box.astype("int")], -1, (0, 0, 255), 2) # draw contours
                    mid_pt_horizontal = (tl[0] + int(abs(tr[0] - tl[0])/2), tl[1] + int(abs(tr[1] - tl[1])/2)) # calculate the horizontal midpoint
                    mid_pt_verticle = (tr[0] + int(abs(tr[0] - br[0])/2), tr[1] + int(abs(tr[1] - br[1])/2)) # calculate the vertical midpoint
                    wid = euclidean(tl, tr)/pixel_per_cm #convert width from pixels to cm
                    ht = euclidean(tr, br)/pixel_per_cm # conver height from pixels to cm
                    cv2.putText(frame, "{:.1f}cm".format(wid), (int(mid_pt_horizontal[0] - 15), int(mid_pt_horizontal[1] - 10)), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2) # annotate the measure of width onf frame
                    cv2.putText(frame, "{:.1f}cm".format(ht), (int(mid_pt_verticle[0] + 10), int(mid_pt_verticle[1])), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2) # annotate the measure of height on frame
                cv2.imshow("final_result" , frame) # show frame
    if cv2.waitKey(1) & 0xFF == ord('q'): #press "q" to Quit the program
        break # break for loop

cap.release() # release camera module
cv2.destroyAllWindows() # destroy windows
